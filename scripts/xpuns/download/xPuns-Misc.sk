on skript load:
	clear {xPuns::chatarg::*}
on command:
	if {xPuns::chatarg::%player%} is set:
		delete {xPuns::chatarg::%player%}
		message "&c&lxPuns&8 » &cCommand cancelled"
on chat:
	if xPunsCheckMute(player) is true:
		set {_id} to {xPuns::muted::%uuid of player%}
		set {_i} to {xPuns::punishment::%{_id}%::issuer}
		set {_i} to {_i} parsed as offline player if {_i} is not "CONSOLE"
		set {_r} to {xPuns::punishment::%{_id}%::reason}
		set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration})
		if {_d} is "Permanent":
			set {_rt} to "Forever"
		else:
			set {_rt} to {_d} parsed as timespan
			set {_t} to {xPuns::punishment::%{_id}%::timestamp}
			add {_rt} to {_t}
			set {_rt} to xPunsGetRemainingTime(difference between now and {_t})
		message "&c&lxPuns&8 » &cYou are muted!%nl%&8 » &7Reason&8: &6%{_r}%%nl%&8 » &7Duration&8: &c%{_d}%%nl%&8 » &7Remaining time&8: &c%{_rt}%%nl%&8 » &7Issued by&8: &b%{_i}%"
		message "&c%{xPuns::punishment::%{_id}%::note}%" if {xPuns::punishment::%{_id}%::note} is not "N/A"
		cancel event
		stop
	if {xPuns::chatarg::%player%} is set:
		cancel event
		if message is "cancel":
			message "&c&lxPuns&8 » &cCommand cancelled"
			clear {xPuns::chatarg::%player%}
			stop
		set {_a::*} to {xPuns::chatarg::%player%} split at ":"
		if {_a::1} is "warnreason":
			make player execute command "warn %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			clear {xPuns::chatarg::%player%}
			stop
		if {_a::1} is "kickreason":
			make player execute command "kick %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			clear {xPuns::chatarg::%player%}
			stop
		if {_a::1} is "mutedur":
			set {_d} to xPunsGetTimespan(uncolored message)
			if {_d} is not "permanent":
				set {xPuns::chatarg::%player%} to "mutereason:%{_a::2}%:%uncolored message%"
			else:
				set {xPuns::chatarg::%player%} to "mutereason:%{_a::2}%"
			message "&c&lxPuns&8 » &7Type the reason you would like to mute &c%{_a::2}% &7for or &ccancel &7to cancel"
			stop
		if {_a::1} is "mutereason":
			if {_a::3} is set:
				make player execute command "mute %{_a::2}% %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			else:
				make player execute command "mute %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			clear {xPuns::chatarg::%player%}
			stop
		if {_a::1} is "bandur":
			set {_d} to xPunsGetTimespan(uncolored message)
			if {_d} is not "permanent":
				set {xPuns::chatarg::%player%} to "banreason:%{_a::2}%:%uncolored message%"
			else:
				set {xPuns::chatarg::%player%} to "banreason:%{_a::2}%"
			message "&c&lxPuns&8 » &7Type the reason you would like to ban &c%{_a::2}% &7for or &ccancel &7to cancel"
			stop
		if {_a::1} is "banreason":
			if {_a::3} is set:
				make player execute command "ban %{_a::2}% %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			else:
				make player execute command "ban %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%"
			clear {xPuns::chatarg::%player%}
			stop
		if {_a::1} is "ipbanreason":
			make player execute command "ipban %{_a::2}% %uncolored message%%{xPuns::silent::%uuid of player%}%%{xPuns::silent::%uuid of player%}%"
			clear {xPuns::chatarg::%player%}
			stop
on join:
	xPunsLogIP(player)
	xPunsLogAccount(player)
	if xPunsCheckIPban(player) is true:
		set {_id} to {xPuns::banned::%uuid of player%}
		set {_i} to {xPuns::punishment::%{_id}%::issuer}
		set {_i} to {_i} parsed as offline player if {_i} is not "CONSOLE"
		set {_r} to {xPuns::punishment::%{_id}%::reason}
		set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration})
		if {_d} is "Permanent":
			set {_rt} to "Forever"
		else:
			set {_rt} to {_d} parsed as timespan
			set {_t} to {xPuns::punishment::%{_id}%::timestamp}
			add {_rt} to {_t}
			set {_rt} to xPunsGetRemainingTime(difference between now and {_t})
		if {xPuns::punishment::%{_id}%::note} is not "N/A":
			kick player because "&7%nl%&c&lxPuns&8 » &cYou are IP-banned!%nl%&8 » &7Reason&8: &6%{_r}%%nl%&8 » &7Duration&8: &c%{_d}%%nl%&8 » &7Remaining time&8: &c%{_rt}%%nl%&8 » &7Issued by&8: &b%{_i}%%nl%&c%{xPuns::punishment::%{_id}%::note}%"
		else:
			kick player because "&7%nl%&c&lxPuns&8 » &cYou are IP-banned!%nl%&8 » &7Reason&8: &6%{_r}%%nl%&8 » &7Duration&8: &c%{_d}%%nl%&8 » &7Remaining time&8: &c%{_rt}%%nl%&8 » &7Issued by&8: &b%{_i}%"
		set join message to ""
		stop
	if xPunsCheckBan(player) is true:
		set {_id} to {xPuns::banned::%uuid of player%}
		set {_i} to {xPuns::punishment::%{_id}%::issuer}
		set {_i} to {_i} parsed as offline player if {_i} is not "CONSOLE"
		set {_r} to {xPuns::punishment::%{_id}%::reason}
		set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration})
		if {_d} is "Permanent":
			set {_rt} to "Forever"
		else:
			set {_rt} to {_d} parsed as timespan
			set {_t} to {xPuns::punishment::%{_id}%::timestamp}
			add {_rt} to {_t}
			set {_rt} to xPunsGetRemainingTime(difference between now and {_t})
		if {xPuns::punishment::%{_id}%::note} is not "N/A":
			kick player because "&7%nl%&c&lxPuns&8 » &cYou are banned!%nl%&8 » &7Reason&8: &6%{_r}%%nl%&8 » &7Duration&8: &c%{_d}%%nl%&8 » &7Remaining time&8: &c%{_rt}%%nl%&8 » &7Issued by&8: &b%{_i}%%nl%&c%{xPuns::punishment::%{_id}%::note}%"
		else:
			kick player because "&7%nl%&c&lxPuns&8 » &cYou are banned!%nl%&8 » &7Reason&8: &6%{_r}%%nl%&8 » &7Duration&8: &c%{_d}%%nl%&8 » &7Remaining time&8: &c%{_rt}%%nl%&8 » &7Issued by&8: &b%{_i}%"
		set join message to ""
		stop
	set {_u::*} to xPunsFetchAccountsFromPlayer(player)
	if size of {_u::*} > 1:
		send "&c&lxPuns&8 » &cAlts detected &8(&b%player%&8)" to all players where [input has permission "xpuns.alts"]
		set {_p::*} to all players
		loop {_u::*}:
			set {_p} to loop-value parsed as offline player
			if xPunsCheckBan({_p}) is true:
				send "&8 » &c%{_p}%" to all players where [input has permission "xpuns.alts"]
			else if xPunsCheckMute({_p}) is true:
				send "&8 » &6%{_p}%" to all players where [input has permission "xpuns.alts"]
			else if {_p::*} contains {_p}:
				send "&8 » &a%{_p}%" to all players where [input has permission "xpuns.alts"]
			else:
				send "&8 » &7%{_p}%" to all players where [input has permission "xpuns.alts"]
	set {_m} to {xPuns::config::joinMessage}
	replace every "$player" in {_m} with "%player%"
	set join message to colored {_m}
on quit:
	delete {xPuns::chatarg::%player%}
	if xPunsCheckBan(player) is true:
		set quit message to ""
		stop
	set {_m} to {xPuns::config::quitMessage}
	replace every "$player" in {_m} with "%player%"
	set quit message to colored {_m}
function xPunsGetRemainingTime(t: timespan) :: text:
	set {_t} to "%{_t}%"
	if {_t} does not contain "and":
		if {_t} does not contain ".":
			return {_t}
			stop
		set {_t::*} to {_t} split at "."
		set {_tu::*} to {_t} split at " "
		return "%{_t::1}% %{_tu::2}%"
	replace every " and " and ", " in {_t} with " "
	set {_t::*} to {_t} split at " "
	set {_1} to "%{_t::1}% %{_t::2}%"
	set {_n} to 0
	loop {_t::*}:
		add 1 to {_n}
		if loop-value parsed as number is a number:
			if {_n} is not 1:
				set {_num} to loop-value parsed as number
	if {_1} contains "day":
		set {_day} to "%{_1}%"
		set {_hour} to floor({_num})
		set {_minute} to ({_num} - floor({_num})) * 60
		set {_minute} to floor({_minute})
		if {_hour} is not 1:
			set {_hr} to "%{_hour}% hours"
		else:
			set {_hr} to "%{_hour}% hour"
		if {_minute} is not 1:
			set {_min} to "%{_minute}% minutes"
		else:
			set {_min} to "%{_minute}% minute"
		return "%{_day}%, %{_hr}% and %{_min}%"
	if {_1} contains "hour":
		set {_hour} to "%{_1}%"
		set {_minute} to floor({_num})
		set {_second} to ({_num} - floor({_num})) * 60
		set {_second} to floor({_second})
		if {_minute} is not 1:
			set {_min} to "%{_minute}% minutes"
		else:
			set {_min} to "%{_minute}% minute"
		if {_second} is not 1:
			set {_sec} to "%{_second}% seconds"
		else:
			set {_sec} to "%{_second}% second"
		return "%{_hour}%, %{_min}% and %{_sec}%"
	if {_1} contains "minute":
		set {_minute} to "%{_1}%"
		set {_second} to floor({_num})
		if {_second} is not 1:
			set {_sec} to "%{_second}% seconds"
		else:
			set {_sec} to "%{_second}% second"
		return "%{_minute}% and %{_sec}%"
	if {_1} contains "second":
		set {_second} to "%{_1}%"
		set {_second} to floor({_num})
		if {_second} is not 1:
			set {_sec} to "%{_second}% seconds"
		else:
			set {_sec} to "%{_second}% second"
		return "%{_minute}% and %{_sec}%"
function xPunsGetTimespan(t: text) :: text:
	if {_t} contains "mo":
		replace every "mo" in {_t} with ""
		set {_n} to {_t} parsed as integer
		set {_ts} to "%{_n}*30% days" parsed as timespan
	if {_t} contains "m":
		replace every "m" in {_t} with ""
		set {_ts} to "%{_t}% minutes" parsed as timespan
	if {_t} contains "s":
		replace every "s" in {_t} with ""
		set {_ts} to "%{_t}% seconds" parsed as timespan
	if {_t} contains "h":
		replace every "h" in {_t} with ""
		set {_ts} to "%{_t}% hours" parsed as timespan
	if {_t} contains "d":
		replace every "d" in {_t} with ""
		set {_ts} to "%{_t}% days" parsed as timespan
	if {_t} contains "w":
		replace every "w" in {_t} with ""
		set {_n} to {_t} parsed as integer
		set {_ts} to "%{_n}*7% days" parsed as timespan
	if {_t} contains "y":
		replace every "y" in {_t} with ""
		set {_n} to {_t} parsed as integer
		set {_ts} to "%{_n}*365% days" parsed as timespan
	if "%{_ts}%" contains "none":
		return "Permanent"
	else:
		return "%{_ts}%"
function xPunsGetUpperTimespan(t: text) :: text:
	set {_u} to xPunsGetTimespan({_t})
	set {_l::*} to split "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z" at ","
	loop {_l::*}:
		replace every loop-value in {_u} with loop-value
	return {_u}
function xPunsAddPunishment(s: sender, p: offline player, t: text, r: text, n: text, d: text, sl: boolean, id: text):
	if {_s} is console:
		set {_us} to "CONSOLE"
	else:
		set {_us} to uuid of {_s}
	set {_up} to uuid of {_p}
	add {_id} to {xPuns::received::%{_up}%::*}
	set {xPuns::punishment::%{_id}%::type} to {_t}
	set {xPuns::punishment::%{_id}%::target} to {_up}
	set {xPuns::punishment::%{_id}%::issuer} to {_us}
	set {xPuns::punishment::%{_id}%::reason} to {_r}
	set {xPuns::punishment::%{_id}%::note} to {_n}
	set {xPuns::punishment::%{_id}%::duration} to {_d}
	set {xPuns::punishment::%{_id}%::timestamp} to now
	if {_sl} is true:
		set {xPuns::punishment::%{_id}%::silent} to "&aTrue"
	else:
		set {xPuns::punishment::%{_id}%::silent} to "&cFalse"
function xPunsFormatHistory(player: player, slot: integer, id: text):
	set {_t} to {xPuns::punishment::%{_id}%::type}
	set {_up} to {xPuns::punishment::%{_id}%::target}
	set {_us} to {xPuns::punishment::%{_id}%::issuer}
	set {_r} to {xPuns::punishment::%{_id}%::reason}
	set {_n} to {xPuns::punishment::%{_id}%::note}
	set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration})
	set {_ts} to {xPuns::punishment::%{_id}%::timestamp}
	set {_sl} to {xPuns::punishment::%{_id}%::silent}
	set {_p} to {_up} parsed as offline player
	set {_s} to "CONSOLE"
	if {_us} is not "CONSOLE":
		set {_s} to {_us} parsed as offline player
	set {_values::*} to split "Warn:lime:&aWarn,Kick:yellow:&eKick,Mute:orange:&6Mute,Ban:red:&cBan,IP-Ban:black:&4IP-Ban" at ","
	loop {_values::*}:
		set {_i::*} to loop-value split at ":"
		if {_i::1} is {_t}:
			set {_i} to "%{_i::2}% dye" parsed as item
			set {_dn} to colored {_i::3}
			stop loop
	if {_t} is "Mute" or "Ban" or "IP-Ban":
		set {_status} to "&aInactive"
		if xPunsCheckMute({_p}) is true:
			if {xPuns::muted::%{_up}%} is {_id}:
				set {_status} to "&cActive"
		if xPunsCheckBan({_p}) is true:
			if {xPuns::banned::%{_up}%} is {_id}:
				set {_status} to "&cActive"
		if xPunsCheckIPban({_p}) is true:
			if {xPuns::banned::%{_up}%} is {_id}:
				set {_status} to "&cActive"
		if {_player} has permission "xpuns.history.clear":
			set slot {_slot} of {_player}'s current inventory to {_i} named {_dn} with lore "&8 » &7Reason&8: &6%{_r}%" and "&8 » &7Duration&8: &c%{_d}%" and "&8 » &7Issuer&8: &b%{_s}%" and "&8 » &7Note&8: &c%{_n}%" and "&8 » &7Status&8: %{_status}%" and "&8 » &7Silent&8: &7%{_sl}%" and "&8 » &7Timestamp&8: &e%{_ts}%" and "" and "&aRight click to remove" and "&7&o%{_id}%"
		else:
			set slot {_slot} of {_player}'s current inventory to {_i} named {_dn} with lore "&8 » &7Reason&8: &6%{_r}%" and "&8 » &7Duration&8: &c%{_d}%" and "&8 » &7Issuer&8: &b%{_s}%" and "&8 » &7Note&8: &c%{_n}%" and "&8 » &7Status&8: %{_status}%" and "&8 » &7Silent&8: &7%{_sl}%" and "&8 » &7Timestamp&8: &e%{_ts}%" and "" and "&7&o%{_id}%"
	else:
		if {_player} has permission "xpuns.history.clear":
			set slot {_slot} of {_player}'s current inventory to {_i} named {_dn} with lore "&8 » &7Reason&8: &6%{_r}%" and "&8 » &7Issuer&8: &b%{_s}%" and "&8 » &7Note&8: &c%{_n}%" and "&8 » &7Silent&8: &7%{_sl}%" and "&8 » &7Timestamp&8: &e%{_ts}%" and "" and "&aRight click to remove" and "&7&o%{_id}%"
		else:
			set slot {_slot} of {_player}'s current inventory to {_i} named {_dn} with lore "&8 » &7Reason&8: &6%{_r}%" and "&8 » &7Issuer&8: &b%{_s}%" and "&8 » &7Note&8: &c%{_n}%" and "&8 » &7Silent&8: &7%{_sl}%" and "&8 » &7Timestamp&8: &e%{_ts}%" and "" and "&7&o%{_id}%"
function xPunsMessage(t: text, p: offline player, i: text, r: text, d: text, note: text, s: boolean):
	set {_m} to {xPuns::config::%{_t}%Message}
	replace every "$TARGET" in {_m} with "%{_p}%"
	replace every "$ISSUER" in {_m} with {_i}
	replace every "$REASON" in {_m} with {_r}
	replace every "$DURATION" in {_m} with {_d}
	if {_s} is false:
		broadcast "&c&lxPuns&8 » %colored {_m}%"
	else:
		send "%{xPuns::config::silentPrefix}%&c&lxPuns&8 » %{_m}%" to all players where [input has permission "xpuns.silent"]
		send "%{xPuns::config::silentPrefix}%&c&lxPuns&8 » %{_m}%" to console
function xPunsMessageIP(t: text, ip: text, i: text, r: text, d: text, s: boolean):
	set {_m} to {xPuns::config::%{_t}%Message}
	replace every "$IP" in {_m} with "%{_ip}%"
	replace every "$ISSUER" in {_m} with {_i}
	replace every "$REASON" in {_m} with {_r}
	replace every "$DURATION" in {_m} with {_d}
	if {_s} is false:
		broadcast "&c&lxPuns&8 » %colored {_m}%"
	else:
		send "%{xPuns::config::silentPrefix}%&c&lxPuns&8 » %{_m}%" to all players where [input has permission "xpuns.silent"]
		send "%{xPuns::config::silentPrefix}%&c&lxPuns&8 » %{_m}%" to console
function xPunsGetRows(i: integer) :: integer:
	set {_o} to floor({_i}/9)+2
	if {_o} > 6:
		return 6
	else:
		return {_o}
function xPunsFormatRows(p: player, i: integer):
	set {_s} to -1
	if {_i} >= 2:
		set {_s} to -1
		loop {_i}*9-9 times:
			add 1 to {_s}
			set slot {_s} of {_p}'s current inventory to gray glass pane named "&7"
		set {_s} to {_i}*9-10
		loop 9 times:
			add 1 to {_s}
			set slot {_s} of {_p}'s current inventory to red glass pane named "&7"
		stop
	loop 9 times:
		add 1 to {_s}
		set slot {_s} of {_p}'s current inventory to gray glass pane named "&7"
function xPunsFormatSilent(p: player, s: integer):
	set {_u} to uuid of {_p}
	if {xPuns::silent::%{_u}%} is not set:
		set slot {_s} of {_p}'s current inventory to oak sign named "&dSilent Mode" with lore "&7Enabled" and "&cDisabled"
	else:
		set slot {_s} of {_p}'s current inventory to oak sign named "&dSilent Mode" with lore "&aEnabled" and "&7Disabled"
function xPunsCheckForSilent(r: text) :: boolean:
	if {_r} contains " -s":
		return true
	else:
		return false
function xPunsGetReason(r: text) :: text:
	replace every " -s" in {_r} with ""
	if {_r} contains " ":
		set {_ts::*} to {_r} split at " "
		if xPunsGetTimespan({_ts::1}) is not "Permanent":
			replace every "%{_ts::1}% " in {_r} with ""
	if {_r} contains " -n ":
		set {_n::*} to {_r} split at " -n "
		set {_r} to {_n::1}
		if length of {_r} < 1:
			set {_r} to "No reason given"
	return uncolored {_r}
function xPunsGetDuration(r: text) :: text:
	replace every " -s" in {_r} with ""
	if {_r} contains " ":
		set {_ts::*} to {_r} split at " "
		if xPunsGetTimespan({_ts::1}) is not "Permanent":
			return {_ts::1}
			stop
	return "Permanent"
function xPunsGetNote(r: text) :: text:
	replace every " -s" in {_r} with ""
	if {_r} contains " -n ":
		set {_n::*} to {_r} split at " -n "
		set {_n} to {_n::2}
		if length of {_n} < 1:
			set {_n} to "N/A"
		return uncolored {_n}
	else:
		return "N/A"
function xPunsCheckMute(p: offline player) :: boolean:
	set {_u} to uuid of {_p}
	if {xPuns::muted::%{_u}%} is set:
		set {_id} to {xPuns::muted::%{_u}%}
		if {xPuns::punishment::%{_id}%::duration} is "Permanent":
			return true
			stop
		set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration}) parsed as timespan
		if difference between {xPuns::punishment::%{_id}%::timestamp} and now < {_d}:
			return true
			stop
		delete {xPuns::muted::%{_u}%}
	return false
function xPunsCheckBan(p: offline player) :: boolean:
	set {_u} to uuid of {_p}
	if {xPuns::banned::%{_u}%} is set:
		set {_id} to {xPuns::banned::%{_u}%}
		if {xPuns::punishment::%{_id}%::duration} is "Permanent":
			return true
			stop
		set {_d} to xPunsGetTimespan({xPuns::punishment::%{_id}%::duration}) parsed as timespan
		if difference between {xPuns::punishment::%{_id}%::timestamp} and now < {_d}:
			return true
			stop
		delete {xPuns::banned::%{_u}%}
	return false
function xPunsLogIP(p: player):
	set {_u} to uuid of {_p}
	set {_ip} to ip of {_p}
	add {_ip} to {xPuns::playerips::%{_u}%::*} if {xPuns::playerips::%{_u}%::*} does not contain {_ip}
function xPunsLogAccount(p: offline player):
	set {_u} to uuid of {_p}
	loop {xPuns::playerips::%{_u}%::*}:
		add {_u} to {xPuns::ipaccounts::%loop-value%::*} if {xPuns::ipaccounts::%loop-value%::*} does not contain {_u}
function xPunsFetchIPs(p: offline player) :: objects:
	set {_u} to uuid of {_p}
	return {xPuns::playerips::%{_u}%::*}
function xPunsFetchAccountsFromPlayer(p: offline player) :: objects:
	set {_ips::*} to xPunsFetchIPs({_p})
	loop {_ips::*}:
		loop {xPuns::ipaccounts::%loop-value%::*}:
			add loop-value-2 to {_u::*} if {_u::*} does not contain loop-value-2
	return {_u::*}
function xPunsFetchAccountsFromIP(ip: text) :: objects:
	return {xPuns::ipaccounts::%{_ip}%::*}
function xPunsCheckIPban(p: offline player) :: boolean:
	set {_u::*} to xPunsFetchAccountsFromPlayer({_p})
	loop {_u::*}:
		if {xPuns::banned::%loop-value%} is set:
			if {xPuns::punishment::%{xPuns::banned::%loop-value%}%::type} is "IP-Ban":
				set {_id} to {xPuns::banned::%loop-value%}
				stop loop
	if {_id} is set:
		loop {_u::*}:
			set {xPuns::banned::%loop-value%} to {_id}
		return true
		stop
	return false
function xPunsCheckIPbanFromIP(ip: text) :: boolean:
	set {_u::*} to xPunsFetchAccountsFromIP({_ip})
	loop {_u::*}:
		if {xPuns::banned::%loop-value%} is set:
			if {xPuns::punishment::%{xPuns::banned::%loop-value%}%::type} is "IP-Ban":
				return true
				stop
	return false
function xPunsCheckPerm(s: sender, p: offline player) :: boolean:
	if {_s} is console:
		return true
		stop
	set {_ns} to 0
	set {_np} to 0
	loop 10 times:
		if {_s} has permission "xpuns.exempt.%loop-value%":
			set {_ns} to loop-value
		if {_p} has permission "xpuns.exempt.%loop-value%":
			set {_np} to loop-value
	if {_ns} > {_np}:
		return true
		stop
	return false
